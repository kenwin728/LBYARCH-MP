1.) Comparative execution time and short analysis of the performance of the kernels
Answer: 
This project focuses on the performance of dot product calculations between two vectors in C and x86-64 assembly. The focus was on vectors of varying sizes - 2^20, 2^24, and 2^29 elements. To ensure a thorough comparison, each calculation was performed 30 times, split evenly across the different vector sizes, with 10 runs for each size, in both Debug and Release modes. We compared the time it took to do these calculations in two different settings: Debug mode, where the code is easier to check for errors but runs slower, and Release mode, where the code runs faster because of extra tuning by the compiler.

Firstly, in debug mode, the performance difference between the C and assembly are minimal, which implies that the extra time it takes just to get the calculation started might hide how fast the computation is done. However, as vector sizes increase, assembly demonstrates a clear advantage in Debug mode, highlighting its potential for optimizing data processing tasks through direct hardware interaction. This advantage highlights assembly's capacity to optimize larger data processing tasks efficiently through direct hardware interaction. Specifically, across 30 runs, the average execution time in Debug mode was 0.346033333 seconds for assembly, compared to 0.4396 seconds for C. On the other hand, in release mode, where the compiler makes the code as efficient as possible, the C version starts to beat the assembly version, especially at larger vector sizes. This highlights the impact of compiler optimizations, such as effective SIMD utilization, making optimized C code significantly more efficient for parallelizable operations like the dot product, with the average execution time in Release mode being 0.304866667 seconds for assembly and 0.205066667 seconds for C across 30 runs. In conclusion, the results show that while writing code in assembly can be helpful in specific situations, using C with compiler optimizations turned on is generally the better choice for making fast and efficient programs, especially for large tasks.

2.) Take a screenshot of the program output with the correctness check (C).
3.) Take a screenshot of the program output, including the correctness check (x86-64).  
Answer for 2-3: 
![MP2-CorrectnessCheck](https://github.com/kenwin728/LBYARCH-MP/assets/114456221/49a62657-b3c0-4ba6-b13e-7411e3e3e49b)
